/*
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// This file has been auto-generated by bindings/code_generator_cobalt.py. DO NOT MODIFY!
// Auto-generated from template: bindings/javascriptcore/templates/interface.cc.template

// clang-format off

#include "third_party/WebKit/Source/JavaScriptCore/config.h"

#include "JSCNumericTypesTestInterface.h"

#include "base/debug/trace_event.h"
#include "cobalt/base/polymorphic_downcast.h"
#include "cobalt/script/global_object_proxy.h"
#include "cobalt/script/opaque_handle.h"
#include "cobalt/script/script_object.h"

#include "cobalt/script/javascriptcore/constructor_base.h"
#include "cobalt/script/javascriptcore/conversion_helpers.h"
#include "cobalt/script/javascriptcore/prototype_base.h"
#include "cobalt/script/javascriptcore/jsc_callback_function.h"
#include "cobalt/script/javascriptcore/jsc_callback_interface_holder.h"
#include "cobalt/script/javascriptcore/jsc_exception_state.h"
#include "cobalt/script/javascriptcore/jsc_global_object.h"
#include "cobalt/script/javascriptcore/jsc_global_object_proxy.h"
#include "cobalt/script/javascriptcore/jsc_object_handle.h"
#include "cobalt/script/javascriptcore/jsc_object_handle_holder.h"
#include "cobalt/script/javascriptcore/type_traits.h"
#include "cobalt/script/javascriptcore/util/binding_helpers.h"
#include "cobalt/script/javascriptcore/util/exception_helpers.h"
#include "third_party/WebKit/Source/JavaScriptCore/interpreter/Interpreter.h"
#include "third_party/WebKit/Source/JavaScriptCore/runtime/Error.h"
#include "third_party/WebKit/Source/JavaScriptCore/runtime/FunctionPrototype.h"
#include "third_party/WebKit/Source/JavaScriptCore/runtime/Identifier.h"
#include "third_party/WebKit/Source/JavaScriptCore/runtime/JSFunction.h"
#include "third_party/WebKit/Source/JavaScriptCore/runtime/JSGlobalObject.h"
#include "third_party/WebKit/Source/JavaScriptCore/runtime/ObjectPrototype.h"

namespace {
using cobalt::bindings::testing::NumericTypesTestInterface;
using cobalt::bindings::testing::JSCNumericTypesTestInterface;
using cobalt::script::CallbackInterfaceTraits;
using cobalt::script::GlobalObjectProxy;
using cobalt::script::OpaqueHandle;
using cobalt::script::OpaqueHandleHolder;
using cobalt::script::ScriptObject;
using cobalt::script::Wrappable;

using cobalt::script::javascriptcore::kConversionFlagNullable;
using cobalt::script::javascriptcore::kConversionFlagRestricted;
using cobalt::script::javascriptcore::kConversionFlagTreatNullAsEmptyString;
using cobalt::script::javascriptcore::kConversionFlagTreatUndefinedAsEmptyString;
using cobalt::script::javascriptcore::kNoConversionFlags;
using cobalt::script::javascriptcore::ConstructorBase;
using cobalt::script::javascriptcore::GetWrappableOrSetException;
using cobalt::script::javascriptcore::FromJSValue;
using cobalt::script::javascriptcore::FromWTFString;
using cobalt::script::javascriptcore::JSCCallbackFunction;
using cobalt::script::javascriptcore::JSCCallbackFunctionHolder;
using cobalt::script::javascriptcore::JSCCallbackInterfaceHolder;
using cobalt::script::javascriptcore::JSCEngine;
using cobalt::script::javascriptcore::JSCExceptionState;
using cobalt::script::javascriptcore::JSCObjectHandle;
using cobalt::script::javascriptcore::JSCObjectHandleHolder;
using cobalt::script::javascriptcore::JSCGlobalObject;
using cobalt::script::javascriptcore::JSCGlobalObjectProxy;
using cobalt::script::javascriptcore::JSObjectToWrappable;
using cobalt::script::javascriptcore::ScriptObjectRegistry;
using cobalt::script::javascriptcore::ToJSValue;
using cobalt::script::javascriptcore::ToWTFString;
using cobalt::script::javascriptcore::TypeTraits;
using cobalt::script::javascriptcore::PrototypeBase;
using cobalt::script::javascriptcore::ThreadLocalHashTable;
using cobalt::script::javascriptcore::WrapperBase;
using cobalt::script::javascriptcore::util::HasPropertyOnPrototype;
using cobalt::script::javascriptcore::util::GetStackTrace;
}  // namespace

namespace cobalt {
namespace bindings {
namespace testing {

namespace {
JSC::JSValue getJSbyteProperty(
    JSC::ExecState* exec_state,
    JSC::JSValue slot_base,
    JSC::PropertyName property_name);
void setJSbyteProperty(
    JSC::ExecState* exec,
    JSC::JSObject* this_object,
    JSC::JSValue value);
JSC::JSValue getJSoctetProperty(
    JSC::ExecState* exec_state,
    JSC::JSValue slot_base,
    JSC::PropertyName property_name);
void setJSoctetProperty(
    JSC::ExecState* exec,
    JSC::JSObject* this_object,
    JSC::JSValue value);
JSC::JSValue getJSshortProperty(
    JSC::ExecState* exec_state,
    JSC::JSValue slot_base,
    JSC::PropertyName property_name);
void setJSshortProperty(
    JSC::ExecState* exec,
    JSC::JSObject* this_object,
    JSC::JSValue value);
JSC::JSValue getJSunsignedShortProperty(
    JSC::ExecState* exec_state,
    JSC::JSValue slot_base,
    JSC::PropertyName property_name);
void setJSunsignedShortProperty(
    JSC::ExecState* exec,
    JSC::JSObject* this_object,
    JSC::JSValue value);
JSC::JSValue getJSlongProperty(
    JSC::ExecState* exec_state,
    JSC::JSValue slot_base,
    JSC::PropertyName property_name);
void setJSlongProperty(
    JSC::ExecState* exec,
    JSC::JSObject* this_object,
    JSC::JSValue value);
JSC::JSValue getJSunsignedLongProperty(
    JSC::ExecState* exec_state,
    JSC::JSValue slot_base,
    JSC::PropertyName property_name);
void setJSunsignedLongProperty(
    JSC::ExecState* exec,
    JSC::JSObject* this_object,
    JSC::JSValue value);
JSC::JSValue getJSlongLongProperty(
    JSC::ExecState* exec_state,
    JSC::JSValue slot_base,
    JSC::PropertyName property_name);
void setJSlongLongProperty(
    JSC::ExecState* exec,
    JSC::JSObject* this_object,
    JSC::JSValue value);
JSC::JSValue getJSunsignedLongLongProperty(
    JSC::ExecState* exec_state,
    JSC::JSValue slot_base,
    JSC::PropertyName property_name);
void setJSunsignedLongLongProperty(
    JSC::ExecState* exec,
    JSC::JSObject* this_object,
    JSC::JSValue value);
JSC::JSValue getJSdoubleProperty(
    JSC::ExecState* exec_state,
    JSC::JSValue slot_base,
    JSC::PropertyName property_name);
void setJSdoubleProperty(
    JSC::ExecState* exec,
    JSC::JSObject* this_object,
    JSC::JSValue value);
JSC::JSValue getJSunrestrictedDoubleProperty(
    JSC::ExecState* exec_state,
    JSC::JSValue slot_base,
    JSC::PropertyName property_name);
void setJSunrestrictedDoubleProperty(
    JSC::ExecState* exec,
    JSC::JSObject* this_object,
    JSC::JSValue value);
JSC::EncodedJSValue functionJSbyteArgumentOperation(JSC::ExecState*);
JSC::EncodedJSValue functionJSbyteReturnOperation(JSC::ExecState*);
JSC::EncodedJSValue functionJSdoubleArgumentOperation(JSC::ExecState*);
JSC::EncodedJSValue functionJSdoubleReturnOperation(JSC::ExecState*);
JSC::EncodedJSValue functionJSlongArgumentOperation(JSC::ExecState*);
JSC::EncodedJSValue functionJSlongLongArgumentOperation(JSC::ExecState*);
JSC::EncodedJSValue functionJSlongLongReturnOperation(JSC::ExecState*);
JSC::EncodedJSValue functionJSlongReturnOperation(JSC::ExecState*);
JSC::EncodedJSValue functionJSoctetArgumentOperation(JSC::ExecState*);
JSC::EncodedJSValue functionJSoctetReturnOperation(JSC::ExecState*);
JSC::EncodedJSValue functionJSshortArgumentOperation(JSC::ExecState*);
JSC::EncodedJSValue functionJSshortReturnOperation(JSC::ExecState*);
JSC::EncodedJSValue functionJSunrestrictedDoubleArgumentOperation(JSC::ExecState*);
JSC::EncodedJSValue functionJSunrestrictedDoubleReturnOperation(JSC::ExecState*);
JSC::EncodedJSValue functionJSunsignedLongArgumentOperation(JSC::ExecState*);
JSC::EncodedJSValue functionJSunsignedLongLongArgumentOperation(JSC::ExecState*);
JSC::EncodedJSValue functionJSunsignedLongLongReturnOperation(JSC::ExecState*);
JSC::EncodedJSValue functionJSunsignedLongReturnOperation(JSC::ExecState*);
JSC::EncodedJSValue functionJSunsignedShortArgumentOperation(JSC::ExecState*);
JSC::EncodedJSValue functionJSunsignedShortReturnOperation(JSC::ExecState*);

// These are declared unconditionally, but only defined if needed by the
// interface.
JSC::JSValue NamedPropertyGetter(JSC::ExecState* exec_state,
    JSC::JSValue slot_base, JSC::PropertyName property_name);
void NamedPropertySetter(JSC::JSCell* cell, JSC::ExecState* exec_state,
    JSC::PropertyName property_name, JSC::JSValue jsc_value);
bool NamedPropertyDeleter(JSC::JSCell* cell, JSC::ExecState* exec_state,
    JSC::PropertyName property_name);
bool QueryNamedProperty(JSC::JSCell* cell, JSC::ExecState* exec_state,
    JSC::PropertyName property_name);
JSC::JSValue OnGetMissingProperty(JSC::ExecState* exec_state,
    JSC::JSValue slot_base, JSC::PropertyName property_name);
bool OnSetMissingProperty(JSC::JSCell* cell, JSC::ExecState* exec_state,
    JSC::PropertyName property_name, JSC::JSValue value);

const bool s_has_named_getter = false;
const bool s_has_named_setter = false;
#if !defined(COBALT_BUILD_TYPE_GOLD)
const bool s_use_debug_missing_property_handler = true;
#else
const bool s_use_debug_missing_property_handler = false;
#endif
}  // namespace

// Class that defines a JS Object representing this interface's Interface Object
// https://www.w3.org/TR/WebIDL/#interface-object
class JSCNumericTypesTestInterface::InterfaceObject : public ConstructorBase {
 public:
  // Get the Interface Object. Will create a new Interface Object if necessary,
  // otherwise it will return the cached one.
  static JSC::JSObject* GetInstance(JSC::ExecState* exec);
  DECLARE_CLASSINFO();

  // Needed when JSC::OverridesGetOwnPropertySlot StructureFlag is set
  // Must be public so that it can be accessible from getStaticValueSlot<>.
  static bool getOwnPropertySlot(JSC::JSCell* cell, JSC::ExecState* exec,
                                 JSC::PropertyName property_name,
                                 JSC::PropertySlot& slot) {
    InterfaceObject* this_object = JSC::jsCast<InterfaceObject*>(cell);
    ASSERT_GC_OBJECT_INHERITS(this_object, &s_info);

    // Same process as JSC::getStaticPropertySlot<>, which is defined in Lookup.h
    // Since JSFunction::getOwnPropertySlot is protected, we can't call it from
    // the helper function.
    const JSC::HashEntry* entry =
        GetPropertyTable(exec)->entry(exec, property_name);

    if (!entry) // not found, forward to parent
      return Base::getOwnPropertySlot(this_object, exec, property_name, slot);

    if (entry->attributes() & JSC::Function)
        return setUpStaticFunctionSlot(exec, entry, this_object, property_name, slot);

    slot.setCacheableCustom(this_object, entry->propertyGetter());
    return true;
  }

  // static override. Needed to support setting a property.
  static void put(JSC::JSCell* cell, JSC::ExecState* exec_state,
                  JSC::PropertyName property_name, JSC::JSValue value,
                  JSC::PutPropertySlot& slot) {
    InterfaceObject* this_object = JSC::jsCast<InterfaceObject*>(cell);
    ASSERT_GC_OBJECT_INHERITS(this_object, &s_info);
    bool found_property = JSC::lookupPut<InterfaceObject>(
        exec_state, property_name, value, GetPropertyTable(exec_state),
        this_object, slot.isStrictMode());
    DLOG_IF(INFO, !found_property) << "Did not find property named " <<
        WTF::String(property_name.publicName()).utf8().data() <<
        " to set on interface object for JSCNumericTypesTestInterface";
    if (!found_property) {
      BaseClass::put(cell, exec_state, property_name, value, slot);
    }
  }

  // static override. This prevents this object from being called as a normal
  // function, throwing a TypeError if the user attempts to do so.
  static JSC::CallType getCallData(JSC::JSCell*, JSC::CallData&) {
    return JSC::CallTypeNone;
  }

  // static override. This prevents this object from being called as a
  // constructor, throwing a TypeError if the user attempts to do so.
  //
  // This method is defined when no constructors are defined on the IDL.
  static JSC::ConstructType getConstructData(JSC::JSCell*, JSC::ConstructData&) {
    return JSC::ConstructTypeNone;
  }

 private:
  typedef ConstructorBase BaseClass;

  static const unsigned StructureFlags =
      JSC::ImplementsHasInstance |
      JSC::OverridesGetOwnPropertySlot |
      BaseClass::StructureFlags;

  InterfaceObject(JSC::ExecState* exec_state, JSC::JSGlobalObject* global_object, JSC::Structure* structure)
      : BaseClass(exec_state, global_object, structure) { }
  void finishCreation(JSC::ExecState* exec_state,
                      JSC::NativeExecutable* native_executable, int length,
                      const String& name);

  static const JSC::HashTable* GetPropertyTable(JSC::ExecState* exec_state);

  static const JSC::HashTableValue property_table_values[];
  static const JSC::HashTable property_table_prototype;
};

const JSC::HashTableValue JSCNumericTypesTestInterface::InterfaceObject::property_table_values[] = {
    // static functions will also go here.
    { 0, 0, 0, 0, static_cast<JSC::Intrinsic>(0) }
};  // JSCNumericTypesTestInterface::InterfaceObject::property_table_values

// static
const JSC::HashTable
JSCNumericTypesTestInterface::InterfaceObject::property_table_prototype = {
    // Sizes will be calculated based on the number of static functions as well.
    2,  // compactSize
    1,  // compactSizeMask
    property_table_values,
    NULL  // table allocated at runtime
};  // JSCNumericTypesTestInterface::InterfaceObject::property_table_prototype

// static
const JSC::HashTable*
JSCNumericTypesTestInterface::InterfaceObject::GetPropertyTable(
    JSC::ExecState* exec_state) {
  return ThreadLocalHashTable::GetInstance()->GetHashTable(
      JSCNumericTypesTestInterface::InterfaceObject::s_classinfo(),
      property_table_prototype);
}

const JSC::ClassInfo JSCNumericTypesTestInterface::InterfaceObject::s_info = {
    "NumericTypesTestInterfaceConstructor",  // className
    BaseClass::s_classinfo(),  // parentClass
    NULL,  // static hash-table of properties (not used)
    GetPropertyTable,  // function pointer to get hash-table of properties
    CREATE_METHOD_TABLE(JSCNumericTypesTestInterface::InterfaceObject)
};  // JSCNumericTypesTestInterface::InterfaceObject::s_info

void JSCNumericTypesTestInterface::InterfaceObject::finishCreation(
    JSC::ExecState* exec_state, JSC::NativeExecutable* native_executable,
    int length, const String& name) {
  BaseClass::finishCreation(exec_state, native_executable, length, name);
  ASSERT(inherits(&s_info));
  // Add a 'prototype' property whose value is the prototype object.
  putDirect(exec_state->globalData(),
            exec_state->propertyNames().prototype,
            JSCNumericTypesTestInterface::GetPrototype(exec_state->lexicalGlobalObject()),
            JSC::DontDelete | JSC::ReadOnly | JSC::DontEnum);
  DCHECK(hasOwnProperty(exec_state, JSC::Identifier(exec_state, "prototype")));
}

// static
JSC::JSObject* JSCNumericTypesTestInterface::InterfaceObject::GetInstance(
    JSC::ExecState* exec_state) {
  JSCGlobalObject* global_object =
      static_cast<JSCGlobalObject*>(exec_state->lexicalGlobalObject());
  ASSERT_GC_OBJECT_INHERITS(global_object, JSCGlobalObject::s_classinfo());

  // Try to get the cached interface object, and create a new one if needed.
  JSC::JSObject* interface_object = global_object->object_cache()->GetCachedConstructor(&s_info);
  if (interface_object == NULL) {
    JSC::JSGlobalData& global_data = global_object->globalData();
    JSC::JSObject* parent_prototype = global_object->functionPrototype();
    JSC::TypeInfo type_info(JSC::ObjectType, StructureFlags);
    JSC::Structure* structure = JSC::Structure::create(
        global_data,
        global_object,
        JSC::JSValue(parent_prototype),
        type_info,
        &s_info);

    const int kNumArguments = 0;
    // NativeExecutable must be non-null even if this is not actually callable.
    JSC::NativeExecutable* executable = global_data.getHostFunction(NULL, NULL);

    // Create the new interface object.
    InterfaceObject* new_interface_object =
        new (NotNull, JSC::allocateCell<InterfaceObject>(global_data.heap))
        InterfaceObject(exec_state, global_object, structure);
    new_interface_object->finishCreation(exec_state, executable, kNumArguments, "NumericTypesTestInterface");
    // Add the interface object to the cache.
    global_object->object_cache()->CacheConstructor(&s_info, new_interface_object);
    interface_object = new_interface_object;
  }
  DCHECK_EQ(global_object->object_cache()->GetCachedConstructor(&s_info), interface_object);
  return interface_object;
}

// End of JSCNumericTypesTestInterface::InterfaceObject class

// Class that defines a JS Object representing this interface's prototype
class JSCNumericTypesTestInterface::Prototype : public PrototypeBase {
 public:
  // Get the prototype. Will create a new prototype if necessary, otherwise it
  // will return a cached prototype.
  static JSC::JSObject* GetInstance(JSC::JSGlobalObject* global_object);
  DECLARE_CLASSINFO();

  // Needed when JSC::OverridesGetOwnPropertySlot StructureFlag is set
  // Must be public so that it can be accessible from getStaticValueSlot<>.
  static bool getOwnPropertySlot(JSC::JSCell*, JSC::ExecState*,
                                 JSC::PropertyName,
                                 JSC::PropertySlot&);

 private:
  typedef PrototypeBase BaseClass;

  static const unsigned StructureFlags =
      JSC::OverridesGetOwnPropertySlot |
      BaseClass::StructureFlags;

  Prototype(JSC::JSGlobalObject* global_object, JSC::Structure* structure)
      : BaseClass(global_object, structure) { }

  static JSC::JSValue GetConstructor(JSC::ExecState* exec_state,
      JSC::JSValue slot_base,
      JSC::PropertyName property_name);
  static const JSC::HashTable* GetPropertyTable(JSC::ExecState* exec_state);

  static const JSC::HashTableValue property_table_values[];
  static const JSC::HashTable property_table_prototype;
};

const JSC::HashTableValue JSCNumericTypesTestInterface::Prototype::property_table_values[] = {
    { "byteArgumentOperation",
        JSC::DontDelete | JSC::Function,
        reinterpret_cast<intptr_t>(functionJSbyteArgumentOperation),
        static_cast<intptr_t>(1),
        JSC::NoIntrinsic
    },
    { "byteReturnOperation",
        JSC::DontDelete | JSC::Function,
        reinterpret_cast<intptr_t>(functionJSbyteReturnOperation),
        static_cast<intptr_t>(0),
        JSC::NoIntrinsic
    },
    { "doubleArgumentOperation",
        JSC::DontDelete | JSC::Function,
        reinterpret_cast<intptr_t>(functionJSdoubleArgumentOperation),
        static_cast<intptr_t>(1),
        JSC::NoIntrinsic
    },
    { "doubleReturnOperation",
        JSC::DontDelete | JSC::Function,
        reinterpret_cast<intptr_t>(functionJSdoubleReturnOperation),
        static_cast<intptr_t>(0),
        JSC::NoIntrinsic
    },
    { "longArgumentOperation",
        JSC::DontDelete | JSC::Function,
        reinterpret_cast<intptr_t>(functionJSlongArgumentOperation),
        static_cast<intptr_t>(1),
        JSC::NoIntrinsic
    },
    { "longLongArgumentOperation",
        JSC::DontDelete | JSC::Function,
        reinterpret_cast<intptr_t>(functionJSlongLongArgumentOperation),
        static_cast<intptr_t>(1),
        JSC::NoIntrinsic
    },
    { "longLongReturnOperation",
        JSC::DontDelete | JSC::Function,
        reinterpret_cast<intptr_t>(functionJSlongLongReturnOperation),
        static_cast<intptr_t>(0),
        JSC::NoIntrinsic
    },
    { "longReturnOperation",
        JSC::DontDelete | JSC::Function,
        reinterpret_cast<intptr_t>(functionJSlongReturnOperation),
        static_cast<intptr_t>(0),
        JSC::NoIntrinsic
    },
    { "octetArgumentOperation",
        JSC::DontDelete | JSC::Function,
        reinterpret_cast<intptr_t>(functionJSoctetArgumentOperation),
        static_cast<intptr_t>(1),
        JSC::NoIntrinsic
    },
    { "octetReturnOperation",
        JSC::DontDelete | JSC::Function,
        reinterpret_cast<intptr_t>(functionJSoctetReturnOperation),
        static_cast<intptr_t>(0),
        JSC::NoIntrinsic
    },
    { "shortArgumentOperation",
        JSC::DontDelete | JSC::Function,
        reinterpret_cast<intptr_t>(functionJSshortArgumentOperation),
        static_cast<intptr_t>(1),
        JSC::NoIntrinsic
    },
    { "shortReturnOperation",
        JSC::DontDelete | JSC::Function,
        reinterpret_cast<intptr_t>(functionJSshortReturnOperation),
        static_cast<intptr_t>(0),
        JSC::NoIntrinsic
    },
    { "unrestrictedDoubleArgumentOperation",
        JSC::DontDelete | JSC::Function,
        reinterpret_cast<intptr_t>(functionJSunrestrictedDoubleArgumentOperation),
        static_cast<intptr_t>(1),
        JSC::NoIntrinsic
    },
    { "unrestrictedDoubleReturnOperation",
        JSC::DontDelete | JSC::Function,
        reinterpret_cast<intptr_t>(functionJSunrestrictedDoubleReturnOperation),
        static_cast<intptr_t>(0),
        JSC::NoIntrinsic
    },
    { "unsignedLongArgumentOperation",
        JSC::DontDelete | JSC::Function,
        reinterpret_cast<intptr_t>(functionJSunsignedLongArgumentOperation),
        static_cast<intptr_t>(1),
        JSC::NoIntrinsic
    },
    { "unsignedLongLongArgumentOperation",
        JSC::DontDelete | JSC::Function,
        reinterpret_cast<intptr_t>(functionJSunsignedLongLongArgumentOperation),
        static_cast<intptr_t>(1),
        JSC::NoIntrinsic
    },
    { "unsignedLongLongReturnOperation",
        JSC::DontDelete | JSC::Function,
        reinterpret_cast<intptr_t>(functionJSunsignedLongLongReturnOperation),
        static_cast<intptr_t>(0),
        JSC::NoIntrinsic
    },
    { "unsignedLongReturnOperation",
        JSC::DontDelete | JSC::Function,
        reinterpret_cast<intptr_t>(functionJSunsignedLongReturnOperation),
        static_cast<intptr_t>(0),
        JSC::NoIntrinsic
    },
    { "unsignedShortArgumentOperation",
        JSC::DontDelete | JSC::Function,
        reinterpret_cast<intptr_t>(functionJSunsignedShortArgumentOperation),
        static_cast<intptr_t>(1),
        JSC::NoIntrinsic
    },
    { "unsignedShortReturnOperation",
        JSC::DontDelete | JSC::Function,
        reinterpret_cast<intptr_t>(functionJSunsignedShortReturnOperation),
        static_cast<intptr_t>(0),
        JSC::NoIntrinsic
    },
    { "constructor",
        JSC::DontDelete | JSC::DontEnum,
        reinterpret_cast<intptr_t>(JSCNumericTypesTestInterface::Prototype::GetConstructor),
        static_cast<intptr_t>(0),
        JSC::NoIntrinsic
    },
    { 0, 0, 0, 0, static_cast<JSC::Intrinsic>(0) }
};  // JSCNumericTypesTestInterface::Prototype::property_table_values

// static
const JSC::HashTable JSCNumericTypesTestInterface::Prototype::property_table_prototype = {
    84,  // compactSize
    63,  // compactSizeMask
    property_table_values,
    NULL  // table allocated at runtime
};  // JSCNumericTypesTestInterface::Prototype::property_table_prototype

// static
const JSC::HashTable* JSCNumericTypesTestInterface::Prototype::GetPropertyTable(
    JSC::ExecState* exec_state) {
  return ThreadLocalHashTable::GetInstance()->GetHashTable(
      JSCNumericTypesTestInterface::Prototype::s_classinfo(), property_table_prototype);
}

const JSC::ClassInfo JSCNumericTypesTestInterface::Prototype::s_info = {
    "NumericTypesTestInterfacePrototype",  // className
    BaseClass::s_classinfo(),  // parentClass
    NULL,  // static hash-table of properties (not used)
    GetPropertyTable,  // function pointer to get hash-table of properties
    CREATE_METHOD_TABLE(JSCNumericTypesTestInterface::Prototype)
};  // JSCNumericTypesTestInterface::Prototype::s_info

// Look up property slot for querying property values.
bool JSCNumericTypesTestInterface::Prototype::getOwnPropertySlot(JSC::JSCell* cell,
    JSC::ExecState* exec, JSC::PropertyName property_name,
    JSC::PropertySlot& slot) {
  Prototype* this_object = JSC::jsCast<Prototype*>(cell);
  ASSERT_GC_OBJECT_INHERITS(this_object, &s_info);
  return JSC::getStaticPropertySlot<Prototype, JSC::JSObject>(
      exec, GetPropertyTable(exec), this_object, property_name, slot);
}

// static
JSC::JSObject* JSCNumericTypesTestInterface::Prototype::GetInstance(
    JSC::JSGlobalObject* base_global_object) {
  JSCGlobalObject* global_object =
      static_cast<JSCGlobalObject*>(base_global_object);
  ASSERT_GC_OBJECT_INHERITS(global_object, JSCGlobalObject::s_classinfo());

  // Try to get the cached prototype, and create a new one if needed.
  JSC::JSObject* prototype = global_object->object_cache()->GetCachedPrototype(&s_info);
  if (prototype == NULL) {
    JSC::JSGlobalData& global_data = global_object->globalData();
    JSC::JSLockHolder lock(&global_data);

    JSC::JSObject* parent_prototype = global_object->objectPrototype();
    JSC::TypeInfo type_info(JSC::ObjectType, StructureFlags);
    JSC::Structure* structure = JSC::Structure::create(
        global_data,
        global_object,
        JSC::JSValue(parent_prototype),
        type_info,
        &s_info);

    // Create the new prototype object.
    Prototype* new_prototype =
        new (NotNull, JSC::allocateCell<Prototype>(
            global_data.heap))
        Prototype(global_object, structure);
    new_prototype->finishCreation(global_data);
    // Add the prototype to the cache.
    global_object->object_cache()->CachePrototype(&s_info, new_prototype);
    prototype = new_prototype;
  }
  DCHECK_EQ(global_object->object_cache()->GetCachedPrototype(&s_info), prototype);
  return prototype;
}

// End of JSCNumericTypesTestInterface::Prototype class

const JSC::HashTableValue JSCNumericTypesTestInterface::property_table_values[] = {
    { "byteProperty",
        JSC::DontDelete ,
        reinterpret_cast<intptr_t>(getJSbyteProperty),
        reinterpret_cast<intptr_t>(setJSbyteProperty),
        JSC::NoIntrinsic
    },
    { "octetProperty",
        JSC::DontDelete ,
        reinterpret_cast<intptr_t>(getJSoctetProperty),
        reinterpret_cast<intptr_t>(setJSoctetProperty),
        JSC::NoIntrinsic
    },
    { "shortProperty",
        JSC::DontDelete ,
        reinterpret_cast<intptr_t>(getJSshortProperty),
        reinterpret_cast<intptr_t>(setJSshortProperty),
        JSC::NoIntrinsic
    },
    { "unsignedShortProperty",
        JSC::DontDelete ,
        reinterpret_cast<intptr_t>(getJSunsignedShortProperty),
        reinterpret_cast<intptr_t>(setJSunsignedShortProperty),
        JSC::NoIntrinsic
    },
    { "longProperty",
        JSC::DontDelete ,
        reinterpret_cast<intptr_t>(getJSlongProperty),
        reinterpret_cast<intptr_t>(setJSlongProperty),
        JSC::NoIntrinsic
    },
    { "unsignedLongProperty",
        JSC::DontDelete ,
        reinterpret_cast<intptr_t>(getJSunsignedLongProperty),
        reinterpret_cast<intptr_t>(setJSunsignedLongProperty),
        JSC::NoIntrinsic
    },
    { "longLongProperty",
        JSC::DontDelete ,
        reinterpret_cast<intptr_t>(getJSlongLongProperty),
        reinterpret_cast<intptr_t>(setJSlongLongProperty),
        JSC::NoIntrinsic
    },
    { "unsignedLongLongProperty",
        JSC::DontDelete ,
        reinterpret_cast<intptr_t>(getJSunsignedLongLongProperty),
        reinterpret_cast<intptr_t>(setJSunsignedLongLongProperty),
        JSC::NoIntrinsic
    },
    { "doubleProperty",
        JSC::DontDelete ,
        reinterpret_cast<intptr_t>(getJSdoubleProperty),
        reinterpret_cast<intptr_t>(setJSdoubleProperty),
        JSC::NoIntrinsic
    },
    { "unrestrictedDoubleProperty",
        JSC::DontDelete ,
        reinterpret_cast<intptr_t>(getJSunrestrictedDoubleProperty),
        reinterpret_cast<intptr_t>(setJSunrestrictedDoubleProperty),
        JSC::NoIntrinsic
    },
    { 0, 0, 0, 0, static_cast<JSC::Intrinsic>(0) }
};  // JSCNumericTypesTestInterface::property_table_values

// static
const JSC::HashTable JSCNumericTypesTestInterface::property_table_prototype = {
    41,  // compactSize
    31,  // compactSizeMask
    property_table_values,
    NULL  // table allocated at runtime
};  // JSCNumericTypesTestInterface::property_table_prototype

// static
const JSC::HashTable* JSCNumericTypesTestInterface::GetPropertyTable(
    JSC::ExecState* exec_state) {
  return ThreadLocalHashTable::GetInstance()->GetHashTable(
      JSCNumericTypesTestInterface::s_classinfo(), property_table_prototype);
}

#ifdef __LB_SHELL__FORCE_LOGGING__
base::LazyInstance<JSCNumericTypesTestInterface::NonTrivialStaticFields>
    JSCNumericTypesTestInterface::non_trivial_static_fields = LAZY_INSTANCE_INITIALIZER;
#endif  // __LB_SHELL__FORCE_LOGGING__

const JSC::ClassInfo JSCNumericTypesTestInterface::s_info = {
    "NumericTypesTestInterface",  // className
    BaseClass::s_classinfo(),  // parentClass
    NULL,  // static hash-table of properties (not used)
    GetPropertyTable,  // function pointer to get hash-table of properties
    CREATE_METHOD_TABLE(JSCNumericTypesTestInterface)
};  // JSCNumericTypesTestInterface::s_info

// static
JSC::JSObject* JSCNumericTypesTestInterface::GetPrototype(
    JSC::JSGlobalObject* global_object) {
  return Prototype::GetInstance(global_object);
}

// static
JSC::JSObject* JSCNumericTypesTestInterface::GetConstructor(
    JSC::ExecState* exec_state) {
  return InterfaceObject::GetInstance(exec_state);
}

// static
JSC::JSValue JSCNumericTypesTestInterface::Prototype::GetConstructor(
      JSC::ExecState* exec_state,
      JSC::JSValue slot_base,
      JSC::PropertyName property_name) {
  return JSC::JSValue(InterfaceObject::GetInstance(exec_state));
}

// static
JSC::JSObject* JSCNumericTypesTestInterface::Create(
    JSCGlobalObject* global_object,
    const scoped_refptr<Wrappable>& wrappable) {
  if (!(wrappable->GetWrappableType() == NumericTypesTestInterface::NumericTypesTestInterfaceWrappableType())) {
    NOTREACHED() << "Type of wrappable does not match NumericTypesTestInterface::NumericTypesTestInterfaceWrappableType()";
    return NULL;
  }
  NumericTypesTestInterface* impl_ptr =
      base::polymorphic_downcast<NumericTypesTestInterface*>(wrappable.get());

  JSC::JSGlobalData& global_data = global_object->globalData();

  // Get or Create the prototype object for this interface.
  JSC::JSObject* prototype = Prototype::GetInstance(global_object);
  DCHECK(prototype);

  JSC::JSLockHolder lock(global_data);
  // Create a JSC::Structure object for this instance.
  JSC::TypeInfo type_info(JSC::ObjectType, StructureFlags);
  JSC::Structure* structure = JSC::Structure::create(
      global_data,
      global_object,
      JSC::JSValue(prototype),
      type_info,
      &s_info);

  // Instantiate a new garbage-collected wrapper object.
  JSCNumericTypesTestInterface* wrapper =
      new (NotNull, JSC::allocateCell<JSCNumericTypesTestInterface>(global_data.heap))
      JSCNumericTypesTestInterface(
          &global_data,
          structure,
          global_object->script_object_registry(),
          make_scoped_refptr(impl_ptr));
  wrapper->finishCreation(global_data);
  return wrapper;
}
JSCNumericTypesTestInterface::JSCNumericTypesTestInterface(
    JSC::JSGlobalData* global_data,
    JSC::Structure* structure,
    ScriptObjectRegistry* script_object_registry,
    const scoped_refptr<NumericTypesTestInterface>& impl)
    : BaseClass(global_data, structure, script_object_registry, impl) {
}

void JSCNumericTypesTestInterface::finishCreation(JSC::JSGlobalData& global_data) {
  BaseClass::finishCreation(global_data);
  DCHECK(inherits(&s_info));
}

JSCNumericTypesTestInterface::~JSCNumericTypesTestInterface() {
  // Empty destructor
}

// Look up property slot for querying property values.
bool JSCNumericTypesTestInterface::getOwnPropertySlot(JSC::JSCell* cell,
    JSC::ExecState* exec, JSC::PropertyName property_name,
    JSC::PropertySlot& slot) {
  JSCNumericTypesTestInterface* this_object = JSC::jsCast<JSCNumericTypesTestInterface*>(cell);
  ASSERT_GC_OBJECT_INHERITS(this_object, &s_info);
  bool found_property_slot = JSC::getStaticValueSlot<JSCNumericTypesTestInterface, BaseClass>(
      exec, GetPropertyTable(exec), this_object, property_name, slot);
  if (s_has_named_getter || s_use_debug_missing_property_handler) {
    bool found_property_on_prototype_chain = false;
    if (!found_property_slot && cell->isObject()) {
      JSC::JSValue prototype_value = JSC::asObject(cell)->prototype();
      if (prototype_value.isObject()) {
        JSC::JSObject* prototype = JSC::asObject(prototype_value);
        found_property_on_prototype_chain =
            prototype->hasProperty(exec, property_name);
      }
    }
    if (s_has_named_getter) {
      if (!found_property_slot && !found_property_on_prototype_chain) {
        if (QueryNamedProperty(this_object, exec, property_name)) {
          slot.setCustom(cell, &NamedPropertyGetter);
          found_property_slot = true;
        }
      }
    }
    if (s_use_debug_missing_property_handler) {
      // The property was not found as an own-property, nor was it found on the
      // prototype chain, so set the missing property handler to be called
      // when getting this property value.
      if (!found_property_slot && !found_property_on_prototype_chain) {
        slot.setCustom(cell, &OnGetMissingProperty);
        found_property_slot = true;
      }
    }
  }
  return found_property_slot;
}

// Look up property slot and put the |value|.
void JSCNumericTypesTestInterface::put(JSC::JSCell* cell, JSC::ExecState* exec,
    JSC::PropertyName property_name, JSC::JSValue value,
    JSC::PutPropertySlot& slot) {
  JSCNumericTypesTestInterface* this_object = JSC::jsCast<JSCNumericTypesTestInterface*>(cell);
  ASSERT_GC_OBJECT_INHERITS(this_object, &s_info);
  bool property_handled = false;
  if (s_has_named_setter || s_use_debug_missing_property_handler) {
    // Need to look up the property manually.
    bool has_property = HasOwnPropertyOrPrototypeProperty(
        cell, exec, property_name);

    if (s_has_named_setter) {
      // We didn't find the property on the object or prototype chain, so
      // set or create a new named property.
      if (!has_property) {
        std::string property_name_utf8 = FromWTFString(property_name.publicName());
        NamedPropertySetter(cell, exec, property_name, value);
        property_handled = true;
      }
    }
    if (s_use_debug_missing_property_handler) {
      if (!has_property && !property_handled) {
        property_handled = OnSetMissingProperty(cell, exec, property_name, value);
      }
    }
#ifdef __LB_SHELL__FORCE_LOGGING__
    std::string property_name_utf8 = FromWTFString(property_name.publicName());

    base::AutoLock lock(non_trivial_static_fields.Get().lock_);
    base::hash_set<std::string>& properties_warned_about =
        non_trivial_static_fields.Get().properties_warned_about;

    if (properties_warned_about.find(property_name_utf8) ==
        properties_warned_about.end()) {
      properties_warned_about.insert(property_name_utf8);
      WTF::String class_name = cell->className();
      DLOG_IF(WARNING, !has_property) << "Did not find property named " <<
              property_name_utf8 << " to set on wrapper for "
              << FromWTFString(class_name)
              << std::endl << StackTraceToString(GetStackTrace(exec, 32))
              << std::endl;
    }
#endif  // __LB_SHELL__FORCE_LOGGING__
  }

  if (!property_handled) {
    JSC::lookupPut<JSCNumericTypesTestInterface, BaseClass>(
        exec, property_name, value, GetPropertyTable(exec), this_object, slot);
  }
}

bool JSCNumericTypesTestInterface::HasOwnPropertyOrPrototypeProperty(
    JSC::JSCell* cell, JSC::ExecState* exec_state,
    JSC::PropertyName property_name) {
  JSCNumericTypesTestInterface* this_object = JSC::jsCast<JSCNumericTypesTestInterface*>(cell);
  JSC::PropertySlot lookup_slot;
  bool has_property = JSC::getStaticPropertySlot<JSCNumericTypesTestInterface, BaseClass>(
      exec_state, GetPropertyTable(exec_state), this_object, property_name,
      lookup_slot);
  return has_property || HasPropertyOnPrototype(exec_state, cell, property_name);
}

namespace {

JSC::JSValue getJSbyteProperty(
    JSC::ExecState* exec_state,
    JSC::JSValue slot_base,
    JSC::PropertyName property_name) {
  TRACE_EVENT0("JSCNumericTypesTestInterface", "get byteProperty");
  JSCGlobalObject* global_object =
      JSC::jsCast<JSCGlobalObject*>(exec_state->lexicalGlobalObject());
  NumericTypesTestInterface* impl =
      GetWrappableOrSetException<NumericTypesTestInterface>(exec_state, slot_base);
  if (!impl) {
    return exec_state->exception();
  }

  JSC::JSValue result = ToJSValue(
      global_object,
      impl->byte_property());
  return result;
}

void setJSbyteProperty(
    JSC::ExecState* exec_state,
    JSC::JSObject* this_object,
    JSC::JSValue value) {
  TRACE_EVENT0("JSCNumericTypesTestInterface", "set byteProperty");
  JSCGlobalObject* global_object =
      JSC::jsCast<JSCGlobalObject*>(exec_state->lexicalGlobalObject());
  JSCExceptionState exception_state(global_object);
  NumericTypesTestInterface* impl =
      GetWrappableOrSetException<NumericTypesTestInterface>(exec_state, this_object);
  if (!impl) {
    return;
  }
  TypeTraits<int8_t >::ConversionType cobalt_value;
  FromJSValue(exec_state, value,
      kNoConversionFlags, &exception_state,
      &cobalt_value);
  if (exception_state.is_exception_set()) {
    JSC::throwError(exec_state, exception_state.exception_object());
    return;
  }
  // Check if argument conversion raised an exception.
  if (!exec_state->hadException()) {
    impl->set_byte_property(cobalt_value);
  }
}

JSC::JSValue getJSoctetProperty(
    JSC::ExecState* exec_state,
    JSC::JSValue slot_base,
    JSC::PropertyName property_name) {
  TRACE_EVENT0("JSCNumericTypesTestInterface", "get octetProperty");
  JSCGlobalObject* global_object =
      JSC::jsCast<JSCGlobalObject*>(exec_state->lexicalGlobalObject());
  NumericTypesTestInterface* impl =
      GetWrappableOrSetException<NumericTypesTestInterface>(exec_state, slot_base);
  if (!impl) {
    return exec_state->exception();
  }

  JSC::JSValue result = ToJSValue(
      global_object,
      impl->octet_property());
  return result;
}

void setJSoctetProperty(
    JSC::ExecState* exec_state,
    JSC::JSObject* this_object,
    JSC::JSValue value) {
  TRACE_EVENT0("JSCNumericTypesTestInterface", "set octetProperty");
  JSCGlobalObject* global_object =
      JSC::jsCast<JSCGlobalObject*>(exec_state->lexicalGlobalObject());
  JSCExceptionState exception_state(global_object);
  NumericTypesTestInterface* impl =
      GetWrappableOrSetException<NumericTypesTestInterface>(exec_state, this_object);
  if (!impl) {
    return;
  }
  TypeTraits<uint8_t >::ConversionType cobalt_value;
  FromJSValue(exec_state, value,
      kNoConversionFlags, &exception_state,
      &cobalt_value);
  if (exception_state.is_exception_set()) {
    JSC::throwError(exec_state, exception_state.exception_object());
    return;
  }
  // Check if argument conversion raised an exception.
  if (!exec_state->hadException()) {
    impl->set_octet_property(cobalt_value);
  }
}

JSC::JSValue getJSshortProperty(
    JSC::ExecState* exec_state,
    JSC::JSValue slot_base,
    JSC::PropertyName property_name) {
  TRACE_EVENT0("JSCNumericTypesTestInterface", "get shortProperty");
  JSCGlobalObject* global_object =
      JSC::jsCast<JSCGlobalObject*>(exec_state->lexicalGlobalObject());
  NumericTypesTestInterface* impl =
      GetWrappableOrSetException<NumericTypesTestInterface>(exec_state, slot_base);
  if (!impl) {
    return exec_state->exception();
  }

  JSC::JSValue result = ToJSValue(
      global_object,
      impl->short_property());
  return result;
}

void setJSshortProperty(
    JSC::ExecState* exec_state,
    JSC::JSObject* this_object,
    JSC::JSValue value) {
  TRACE_EVENT0("JSCNumericTypesTestInterface", "set shortProperty");
  JSCGlobalObject* global_object =
      JSC::jsCast<JSCGlobalObject*>(exec_state->lexicalGlobalObject());
  JSCExceptionState exception_state(global_object);
  NumericTypesTestInterface* impl =
      GetWrappableOrSetException<NumericTypesTestInterface>(exec_state, this_object);
  if (!impl) {
    return;
  }
  TypeTraits<int16_t >::ConversionType cobalt_value;
  FromJSValue(exec_state, value,
      kNoConversionFlags, &exception_state,
      &cobalt_value);
  if (exception_state.is_exception_set()) {
    JSC::throwError(exec_state, exception_state.exception_object());
    return;
  }
  // Check if argument conversion raised an exception.
  if (!exec_state->hadException()) {
    impl->set_short_property(cobalt_value);
  }
}

JSC::JSValue getJSunsignedShortProperty(
    JSC::ExecState* exec_state,
    JSC::JSValue slot_base,
    JSC::PropertyName property_name) {
  TRACE_EVENT0("JSCNumericTypesTestInterface", "get unsignedShortProperty");
  JSCGlobalObject* global_object =
      JSC::jsCast<JSCGlobalObject*>(exec_state->lexicalGlobalObject());
  NumericTypesTestInterface* impl =
      GetWrappableOrSetException<NumericTypesTestInterface>(exec_state, slot_base);
  if (!impl) {
    return exec_state->exception();
  }

  JSC::JSValue result = ToJSValue(
      global_object,
      impl->unsigned_short_property());
  return result;
}

void setJSunsignedShortProperty(
    JSC::ExecState* exec_state,
    JSC::JSObject* this_object,
    JSC::JSValue value) {
  TRACE_EVENT0("JSCNumericTypesTestInterface", "set unsignedShortProperty");
  JSCGlobalObject* global_object =
      JSC::jsCast<JSCGlobalObject*>(exec_state->lexicalGlobalObject());
  JSCExceptionState exception_state(global_object);
  NumericTypesTestInterface* impl =
      GetWrappableOrSetException<NumericTypesTestInterface>(exec_state, this_object);
  if (!impl) {
    return;
  }
  TypeTraits<uint16_t >::ConversionType cobalt_value;
  FromJSValue(exec_state, value,
      kNoConversionFlags, &exception_state,
      &cobalt_value);
  if (exception_state.is_exception_set()) {
    JSC::throwError(exec_state, exception_state.exception_object());
    return;
  }
  // Check if argument conversion raised an exception.
  if (!exec_state->hadException()) {
    impl->set_unsigned_short_property(cobalt_value);
  }
}

JSC::JSValue getJSlongProperty(
    JSC::ExecState* exec_state,
    JSC::JSValue slot_base,
    JSC::PropertyName property_name) {
  TRACE_EVENT0("JSCNumericTypesTestInterface", "get longProperty");
  JSCGlobalObject* global_object =
      JSC::jsCast<JSCGlobalObject*>(exec_state->lexicalGlobalObject());
  NumericTypesTestInterface* impl =
      GetWrappableOrSetException<NumericTypesTestInterface>(exec_state, slot_base);
  if (!impl) {
    return exec_state->exception();
  }

  JSC::JSValue result = ToJSValue(
      global_object,
      impl->long_property());
  return result;
}

void setJSlongProperty(
    JSC::ExecState* exec_state,
    JSC::JSObject* this_object,
    JSC::JSValue value) {
  TRACE_EVENT0("JSCNumericTypesTestInterface", "set longProperty");
  JSCGlobalObject* global_object =
      JSC::jsCast<JSCGlobalObject*>(exec_state->lexicalGlobalObject());
  JSCExceptionState exception_state(global_object);
  NumericTypesTestInterface* impl =
      GetWrappableOrSetException<NumericTypesTestInterface>(exec_state, this_object);
  if (!impl) {
    return;
  }
  TypeTraits<int32_t >::ConversionType cobalt_value;
  FromJSValue(exec_state, value,
      kNoConversionFlags, &exception_state,
      &cobalt_value);
  if (exception_state.is_exception_set()) {
    JSC::throwError(exec_state, exception_state.exception_object());
    return;
  }
  // Check if argument conversion raised an exception.
  if (!exec_state->hadException()) {
    impl->set_long_property(cobalt_value);
  }
}

JSC::JSValue getJSunsignedLongProperty(
    JSC::ExecState* exec_state,
    JSC::JSValue slot_base,
    JSC::PropertyName property_name) {
  TRACE_EVENT0("JSCNumericTypesTestInterface", "get unsignedLongProperty");
  JSCGlobalObject* global_object =
      JSC::jsCast<JSCGlobalObject*>(exec_state->lexicalGlobalObject());
  NumericTypesTestInterface* impl =
      GetWrappableOrSetException<NumericTypesTestInterface>(exec_state, slot_base);
  if (!impl) {
    return exec_state->exception();
  }

  JSC::JSValue result = ToJSValue(
      global_object,
      impl->unsigned_long_property());
  return result;
}

void setJSunsignedLongProperty(
    JSC::ExecState* exec_state,
    JSC::JSObject* this_object,
    JSC::JSValue value) {
  TRACE_EVENT0("JSCNumericTypesTestInterface", "set unsignedLongProperty");
  JSCGlobalObject* global_object =
      JSC::jsCast<JSCGlobalObject*>(exec_state->lexicalGlobalObject());
  JSCExceptionState exception_state(global_object);
  NumericTypesTestInterface* impl =
      GetWrappableOrSetException<NumericTypesTestInterface>(exec_state, this_object);
  if (!impl) {
    return;
  }
  TypeTraits<uint32_t >::ConversionType cobalt_value;
  FromJSValue(exec_state, value,
      kNoConversionFlags, &exception_state,
      &cobalt_value);
  if (exception_state.is_exception_set()) {
    JSC::throwError(exec_state, exception_state.exception_object());
    return;
  }
  // Check if argument conversion raised an exception.
  if (!exec_state->hadException()) {
    impl->set_unsigned_long_property(cobalt_value);
  }
}

JSC::JSValue getJSlongLongProperty(
    JSC::ExecState* exec_state,
    JSC::JSValue slot_base,
    JSC::PropertyName property_name) {
  TRACE_EVENT0("JSCNumericTypesTestInterface", "get longLongProperty");
  JSCGlobalObject* global_object =
      JSC::jsCast<JSCGlobalObject*>(exec_state->lexicalGlobalObject());
  NumericTypesTestInterface* impl =
      GetWrappableOrSetException<NumericTypesTestInterface>(exec_state, slot_base);
  if (!impl) {
    return exec_state->exception();
  }

  JSC::JSValue result = ToJSValue(
      global_object,
      impl->long_long_property());
  return result;
}

void setJSlongLongProperty(
    JSC::ExecState* exec_state,
    JSC::JSObject* this_object,
    JSC::JSValue value) {
  TRACE_EVENT0("JSCNumericTypesTestInterface", "set longLongProperty");
  JSCGlobalObject* global_object =
      JSC::jsCast<JSCGlobalObject*>(exec_state->lexicalGlobalObject());
  JSCExceptionState exception_state(global_object);
  NumericTypesTestInterface* impl =
      GetWrappableOrSetException<NumericTypesTestInterface>(exec_state, this_object);
  if (!impl) {
    return;
  }
  TypeTraits<int64_t >::ConversionType cobalt_value;
  FromJSValue(exec_state, value,
      kNoConversionFlags, &exception_state,
      &cobalt_value);
  if (exception_state.is_exception_set()) {
    JSC::throwError(exec_state, exception_state.exception_object());
    return;
  }
  // Check if argument conversion raised an exception.
  if (!exec_state->hadException()) {
    impl->set_long_long_property(cobalt_value);
  }
}

JSC::JSValue getJSunsignedLongLongProperty(
    JSC::ExecState* exec_state,
    JSC::JSValue slot_base,
    JSC::PropertyName property_name) {
  TRACE_EVENT0("JSCNumericTypesTestInterface", "get unsignedLongLongProperty");
  JSCGlobalObject* global_object =
      JSC::jsCast<JSCGlobalObject*>(exec_state->lexicalGlobalObject());
  NumericTypesTestInterface* impl =
      GetWrappableOrSetException<NumericTypesTestInterface>(exec_state, slot_base);
  if (!impl) {
    return exec_state->exception();
  }

  JSC::JSValue result = ToJSValue(
      global_object,
      impl->unsigned_long_long_property());
  return result;
}

void setJSunsignedLongLongProperty(
    JSC::ExecState* exec_state,
    JSC::JSObject* this_object,
    JSC::JSValue value) {
  TRACE_EVENT0("JSCNumericTypesTestInterface", "set unsignedLongLongProperty");
  JSCGlobalObject* global_object =
      JSC::jsCast<JSCGlobalObject*>(exec_state->lexicalGlobalObject());
  JSCExceptionState exception_state(global_object);
  NumericTypesTestInterface* impl =
      GetWrappableOrSetException<NumericTypesTestInterface>(exec_state, this_object);
  if (!impl) {
    return;
  }
  TypeTraits<uint64_t >::ConversionType cobalt_value;
  FromJSValue(exec_state, value,
      kNoConversionFlags, &exception_state,
      &cobalt_value);
  if (exception_state.is_exception_set()) {
    JSC::throwError(exec_state, exception_state.exception_object());
    return;
  }
  // Check if argument conversion raised an exception.
  if (!exec_state->hadException()) {
    impl->set_unsigned_long_long_property(cobalt_value);
  }
}

JSC::JSValue getJSdoubleProperty(
    JSC::ExecState* exec_state,
    JSC::JSValue slot_base,
    JSC::PropertyName property_name) {
  TRACE_EVENT0("JSCNumericTypesTestInterface", "get doubleProperty");
  JSCGlobalObject* global_object =
      JSC::jsCast<JSCGlobalObject*>(exec_state->lexicalGlobalObject());
  NumericTypesTestInterface* impl =
      GetWrappableOrSetException<NumericTypesTestInterface>(exec_state, slot_base);
  if (!impl) {
    return exec_state->exception();
  }

  JSC::JSValue result = ToJSValue(
      global_object,
      impl->double_property());
  return result;
}

void setJSdoubleProperty(
    JSC::ExecState* exec_state,
    JSC::JSObject* this_object,
    JSC::JSValue value) {
  TRACE_EVENT0("JSCNumericTypesTestInterface", "set doubleProperty");
  JSCGlobalObject* global_object =
      JSC::jsCast<JSCGlobalObject*>(exec_state->lexicalGlobalObject());
  JSCExceptionState exception_state(global_object);
  NumericTypesTestInterface* impl =
      GetWrappableOrSetException<NumericTypesTestInterface>(exec_state, this_object);
  if (!impl) {
    return;
  }
  TypeTraits<double >::ConversionType cobalt_value;
  FromJSValue(exec_state, value,
      (kConversionFlagRestricted), &exception_state,
      &cobalt_value);
  if (exception_state.is_exception_set()) {
    JSC::throwError(exec_state, exception_state.exception_object());
    return;
  }
  // Check if argument conversion raised an exception.
  if (!exec_state->hadException()) {
    impl->set_double_property(cobalt_value);
  }
}

JSC::JSValue getJSunrestrictedDoubleProperty(
    JSC::ExecState* exec_state,
    JSC::JSValue slot_base,
    JSC::PropertyName property_name) {
  TRACE_EVENT0("JSCNumericTypesTestInterface", "get unrestrictedDoubleProperty");
  JSCGlobalObject* global_object =
      JSC::jsCast<JSCGlobalObject*>(exec_state->lexicalGlobalObject());
  NumericTypesTestInterface* impl =
      GetWrappableOrSetException<NumericTypesTestInterface>(exec_state, slot_base);
  if (!impl) {
    return exec_state->exception();
  }

  JSC::JSValue result = ToJSValue(
      global_object,
      impl->unrestricted_double_property());
  return result;
}

void setJSunrestrictedDoubleProperty(
    JSC::ExecState* exec_state,
    JSC::JSObject* this_object,
    JSC::JSValue value) {
  TRACE_EVENT0("JSCNumericTypesTestInterface", "set unrestrictedDoubleProperty");
  JSCGlobalObject* global_object =
      JSC::jsCast<JSCGlobalObject*>(exec_state->lexicalGlobalObject());
  JSCExceptionState exception_state(global_object);
  NumericTypesTestInterface* impl =
      GetWrappableOrSetException<NumericTypesTestInterface>(exec_state, this_object);
  if (!impl) {
    return;
  }
  TypeTraits<double >::ConversionType cobalt_value;
  FromJSValue(exec_state, value,
      kNoConversionFlags, &exception_state,
      &cobalt_value);
  if (exception_state.is_exception_set()) {
    JSC::throwError(exec_state, exception_state.exception_object());
    return;
  }
  // Check if argument conversion raised an exception.
  if (!exec_state->hadException()) {
    impl->set_unrestricted_double_property(cobalt_value);
  }
}

JSC::EncodedJSValue functionJSbyteArgumentOperation(
    JSC::ExecState* exec_state) {
  TRACE_EVENT0("JSCNumericTypesTestInterface", "call byteArgumentOperation");
  JSCGlobalObject* global_object =
      JSC::jsCast<JSCGlobalObject*>(exec_state->lexicalGlobalObject());
  JSCExceptionState exception_state(global_object);
  JSC::JSObject* this_object =
      exec_state->hostThisValue().toThisObject(exec_state);
  NumericTypesTestInterface* impl =
      GetWrappableOrSetException<NumericTypesTestInterface>(exec_state, this_object);
  if (!impl) {
    return JSC::JSValue::encode(exec_state->exception());
  }

  const size_t kMinArguments = 1;
  if (exec_state->argumentCount() < kMinArguments) {
    return JSC::throwVMNotEnoughArgumentsError(exec_state);
  }
  // Non-optional arguments
  TypeTraits<int8_t >::ConversionType arg1;

  DCHECK_LT(0, exec_state->argumentCount());
  FromJSValue(exec_state,
      exec_state->argument(0),
      kNoConversionFlags,
      &exception_state, &arg1);
  if (exception_state.is_exception_set()) {
    return JSC::throwVMError(exec_state, exception_state.exception_object());
  }
  impl->ByteArgumentOperation(arg1);
  return JSC::JSValue::encode(JSC::jsUndefined());

}

JSC::EncodedJSValue functionJSbyteReturnOperation(
    JSC::ExecState* exec_state) {
  TRACE_EVENT0("JSCNumericTypesTestInterface", "call byteReturnOperation");
  JSCGlobalObject* global_object =
      JSC::jsCast<JSCGlobalObject*>(exec_state->lexicalGlobalObject());
  JSCExceptionState exception_state(global_object);
  JSC::JSObject* this_object =
      exec_state->hostThisValue().toThisObject(exec_state);
  NumericTypesTestInterface* impl =
      GetWrappableOrSetException<NumericTypesTestInterface>(exec_state, this_object);
  if (!impl) {
    return JSC::JSValue::encode(exec_state->exception());
  }

  TypeTraits<int8_t >::ReturnType return_value = impl->ByteReturnOperation();
  return JSC::JSValue::encode(ToJSValue(global_object, return_value));

}

JSC::EncodedJSValue functionJSdoubleArgumentOperation(
    JSC::ExecState* exec_state) {
  TRACE_EVENT0("JSCNumericTypesTestInterface", "call doubleArgumentOperation");
  JSCGlobalObject* global_object =
      JSC::jsCast<JSCGlobalObject*>(exec_state->lexicalGlobalObject());
  JSCExceptionState exception_state(global_object);
  JSC::JSObject* this_object =
      exec_state->hostThisValue().toThisObject(exec_state);
  NumericTypesTestInterface* impl =
      GetWrappableOrSetException<NumericTypesTestInterface>(exec_state, this_object);
  if (!impl) {
    return JSC::JSValue::encode(exec_state->exception());
  }

  const size_t kMinArguments = 1;
  if (exec_state->argumentCount() < kMinArguments) {
    return JSC::throwVMNotEnoughArgumentsError(exec_state);
  }
  // Non-optional arguments
  TypeTraits<double >::ConversionType arg1;

  DCHECK_LT(0, exec_state->argumentCount());
  FromJSValue(exec_state,
      exec_state->argument(0),
      (kConversionFlagRestricted),
      &exception_state, &arg1);
  if (exception_state.is_exception_set()) {
    return JSC::throwVMError(exec_state, exception_state.exception_object());
  }
  impl->DoubleArgumentOperation(arg1);
  return JSC::JSValue::encode(JSC::jsUndefined());

}

JSC::EncodedJSValue functionJSdoubleReturnOperation(
    JSC::ExecState* exec_state) {
  TRACE_EVENT0("JSCNumericTypesTestInterface", "call doubleReturnOperation");
  JSCGlobalObject* global_object =
      JSC::jsCast<JSCGlobalObject*>(exec_state->lexicalGlobalObject());
  JSCExceptionState exception_state(global_object);
  JSC::JSObject* this_object =
      exec_state->hostThisValue().toThisObject(exec_state);
  NumericTypesTestInterface* impl =
      GetWrappableOrSetException<NumericTypesTestInterface>(exec_state, this_object);
  if (!impl) {
    return JSC::JSValue::encode(exec_state->exception());
  }

  TypeTraits<double >::ReturnType return_value = impl->DoubleReturnOperation();
  return JSC::JSValue::encode(ToJSValue(global_object, return_value));

}

JSC::EncodedJSValue functionJSlongArgumentOperation(
    JSC::ExecState* exec_state) {
  TRACE_EVENT0("JSCNumericTypesTestInterface", "call longArgumentOperation");
  JSCGlobalObject* global_object =
      JSC::jsCast<JSCGlobalObject*>(exec_state->lexicalGlobalObject());
  JSCExceptionState exception_state(global_object);
  JSC::JSObject* this_object =
      exec_state->hostThisValue().toThisObject(exec_state);
  NumericTypesTestInterface* impl =
      GetWrappableOrSetException<NumericTypesTestInterface>(exec_state, this_object);
  if (!impl) {
    return JSC::JSValue::encode(exec_state->exception());
  }

  const size_t kMinArguments = 1;
  if (exec_state->argumentCount() < kMinArguments) {
    return JSC::throwVMNotEnoughArgumentsError(exec_state);
  }
  // Non-optional arguments
  TypeTraits<int32_t >::ConversionType arg1;

  DCHECK_LT(0, exec_state->argumentCount());
  FromJSValue(exec_state,
      exec_state->argument(0),
      kNoConversionFlags,
      &exception_state, &arg1);
  if (exception_state.is_exception_set()) {
    return JSC::throwVMError(exec_state, exception_state.exception_object());
  }
  impl->LongArgumentOperation(arg1);
  return JSC::JSValue::encode(JSC::jsUndefined());

}

JSC::EncodedJSValue functionJSlongLongArgumentOperation(
    JSC::ExecState* exec_state) {
  TRACE_EVENT0("JSCNumericTypesTestInterface", "call longLongArgumentOperation");
  JSCGlobalObject* global_object =
      JSC::jsCast<JSCGlobalObject*>(exec_state->lexicalGlobalObject());
  JSCExceptionState exception_state(global_object);
  JSC::JSObject* this_object =
      exec_state->hostThisValue().toThisObject(exec_state);
  NumericTypesTestInterface* impl =
      GetWrappableOrSetException<NumericTypesTestInterface>(exec_state, this_object);
  if (!impl) {
    return JSC::JSValue::encode(exec_state->exception());
  }

  const size_t kMinArguments = 1;
  if (exec_state->argumentCount() < kMinArguments) {
    return JSC::throwVMNotEnoughArgumentsError(exec_state);
  }
  // Non-optional arguments
  TypeTraits<int64_t >::ConversionType arg1;

  DCHECK_LT(0, exec_state->argumentCount());
  FromJSValue(exec_state,
      exec_state->argument(0),
      kNoConversionFlags,
      &exception_state, &arg1);
  if (exception_state.is_exception_set()) {
    return JSC::throwVMError(exec_state, exception_state.exception_object());
  }
  impl->LongLongArgumentOperation(arg1);
  return JSC::JSValue::encode(JSC::jsUndefined());

}

JSC::EncodedJSValue functionJSlongLongReturnOperation(
    JSC::ExecState* exec_state) {
  TRACE_EVENT0("JSCNumericTypesTestInterface", "call longLongReturnOperation");
  JSCGlobalObject* global_object =
      JSC::jsCast<JSCGlobalObject*>(exec_state->lexicalGlobalObject());
  JSCExceptionState exception_state(global_object);
  JSC::JSObject* this_object =
      exec_state->hostThisValue().toThisObject(exec_state);
  NumericTypesTestInterface* impl =
      GetWrappableOrSetException<NumericTypesTestInterface>(exec_state, this_object);
  if (!impl) {
    return JSC::JSValue::encode(exec_state->exception());
  }

  TypeTraits<int64_t >::ReturnType return_value = impl->LongLongReturnOperation();
  return JSC::JSValue::encode(ToJSValue(global_object, return_value));

}

JSC::EncodedJSValue functionJSlongReturnOperation(
    JSC::ExecState* exec_state) {
  TRACE_EVENT0("JSCNumericTypesTestInterface", "call longReturnOperation");
  JSCGlobalObject* global_object =
      JSC::jsCast<JSCGlobalObject*>(exec_state->lexicalGlobalObject());
  JSCExceptionState exception_state(global_object);
  JSC::JSObject* this_object =
      exec_state->hostThisValue().toThisObject(exec_state);
  NumericTypesTestInterface* impl =
      GetWrappableOrSetException<NumericTypesTestInterface>(exec_state, this_object);
  if (!impl) {
    return JSC::JSValue::encode(exec_state->exception());
  }

  TypeTraits<int32_t >::ReturnType return_value = impl->LongReturnOperation();
  return JSC::JSValue::encode(ToJSValue(global_object, return_value));

}

JSC::EncodedJSValue functionJSoctetArgumentOperation(
    JSC::ExecState* exec_state) {
  TRACE_EVENT0("JSCNumericTypesTestInterface", "call octetArgumentOperation");
  JSCGlobalObject* global_object =
      JSC::jsCast<JSCGlobalObject*>(exec_state->lexicalGlobalObject());
  JSCExceptionState exception_state(global_object);
  JSC::JSObject* this_object =
      exec_state->hostThisValue().toThisObject(exec_state);
  NumericTypesTestInterface* impl =
      GetWrappableOrSetException<NumericTypesTestInterface>(exec_state, this_object);
  if (!impl) {
    return JSC::JSValue::encode(exec_state->exception());
  }

  const size_t kMinArguments = 1;
  if (exec_state->argumentCount() < kMinArguments) {
    return JSC::throwVMNotEnoughArgumentsError(exec_state);
  }
  // Non-optional arguments
  TypeTraits<uint8_t >::ConversionType arg1;

  DCHECK_LT(0, exec_state->argumentCount());
  FromJSValue(exec_state,
      exec_state->argument(0),
      kNoConversionFlags,
      &exception_state, &arg1);
  if (exception_state.is_exception_set()) {
    return JSC::throwVMError(exec_state, exception_state.exception_object());
  }
  impl->OctetArgumentOperation(arg1);
  return JSC::JSValue::encode(JSC::jsUndefined());

}

JSC::EncodedJSValue functionJSoctetReturnOperation(
    JSC::ExecState* exec_state) {
  TRACE_EVENT0("JSCNumericTypesTestInterface", "call octetReturnOperation");
  JSCGlobalObject* global_object =
      JSC::jsCast<JSCGlobalObject*>(exec_state->lexicalGlobalObject());
  JSCExceptionState exception_state(global_object);
  JSC::JSObject* this_object =
      exec_state->hostThisValue().toThisObject(exec_state);
  NumericTypesTestInterface* impl =
      GetWrappableOrSetException<NumericTypesTestInterface>(exec_state, this_object);
  if (!impl) {
    return JSC::JSValue::encode(exec_state->exception());
  }

  TypeTraits<uint8_t >::ReturnType return_value = impl->OctetReturnOperation();
  return JSC::JSValue::encode(ToJSValue(global_object, return_value));

}

JSC::EncodedJSValue functionJSshortArgumentOperation(
    JSC::ExecState* exec_state) {
  TRACE_EVENT0("JSCNumericTypesTestInterface", "call shortArgumentOperation");
  JSCGlobalObject* global_object =
      JSC::jsCast<JSCGlobalObject*>(exec_state->lexicalGlobalObject());
  JSCExceptionState exception_state(global_object);
  JSC::JSObject* this_object =
      exec_state->hostThisValue().toThisObject(exec_state);
  NumericTypesTestInterface* impl =
      GetWrappableOrSetException<NumericTypesTestInterface>(exec_state, this_object);
  if (!impl) {
    return JSC::JSValue::encode(exec_state->exception());
  }

  const size_t kMinArguments = 1;
  if (exec_state->argumentCount() < kMinArguments) {
    return JSC::throwVMNotEnoughArgumentsError(exec_state);
  }
  // Non-optional arguments
  TypeTraits<int16_t >::ConversionType arg1;

  DCHECK_LT(0, exec_state->argumentCount());
  FromJSValue(exec_state,
      exec_state->argument(0),
      kNoConversionFlags,
      &exception_state, &arg1);
  if (exception_state.is_exception_set()) {
    return JSC::throwVMError(exec_state, exception_state.exception_object());
  }
  impl->ShortArgumentOperation(arg1);
  return JSC::JSValue::encode(JSC::jsUndefined());

}

JSC::EncodedJSValue functionJSshortReturnOperation(
    JSC::ExecState* exec_state) {
  TRACE_EVENT0("JSCNumericTypesTestInterface", "call shortReturnOperation");
  JSCGlobalObject* global_object =
      JSC::jsCast<JSCGlobalObject*>(exec_state->lexicalGlobalObject());
  JSCExceptionState exception_state(global_object);
  JSC::JSObject* this_object =
      exec_state->hostThisValue().toThisObject(exec_state);
  NumericTypesTestInterface* impl =
      GetWrappableOrSetException<NumericTypesTestInterface>(exec_state, this_object);
  if (!impl) {
    return JSC::JSValue::encode(exec_state->exception());
  }

  TypeTraits<int16_t >::ReturnType return_value = impl->ShortReturnOperation();
  return JSC::JSValue::encode(ToJSValue(global_object, return_value));

}

JSC::EncodedJSValue functionJSunrestrictedDoubleArgumentOperation(
    JSC::ExecState* exec_state) {
  TRACE_EVENT0("JSCNumericTypesTestInterface", "call unrestrictedDoubleArgumentOperation");
  JSCGlobalObject* global_object =
      JSC::jsCast<JSCGlobalObject*>(exec_state->lexicalGlobalObject());
  JSCExceptionState exception_state(global_object);
  JSC::JSObject* this_object =
      exec_state->hostThisValue().toThisObject(exec_state);
  NumericTypesTestInterface* impl =
      GetWrappableOrSetException<NumericTypesTestInterface>(exec_state, this_object);
  if (!impl) {
    return JSC::JSValue::encode(exec_state->exception());
  }

  const size_t kMinArguments = 1;
  if (exec_state->argumentCount() < kMinArguments) {
    return JSC::throwVMNotEnoughArgumentsError(exec_state);
  }
  // Non-optional arguments
  TypeTraits<double >::ConversionType arg1;

  DCHECK_LT(0, exec_state->argumentCount());
  FromJSValue(exec_state,
      exec_state->argument(0),
      kNoConversionFlags,
      &exception_state, &arg1);
  if (exception_state.is_exception_set()) {
    return JSC::throwVMError(exec_state, exception_state.exception_object());
  }
  impl->UnrestrictedDoubleArgumentOperation(arg1);
  return JSC::JSValue::encode(JSC::jsUndefined());

}

JSC::EncodedJSValue functionJSunrestrictedDoubleReturnOperation(
    JSC::ExecState* exec_state) {
  TRACE_EVENT0("JSCNumericTypesTestInterface", "call unrestrictedDoubleReturnOperation");
  JSCGlobalObject* global_object =
      JSC::jsCast<JSCGlobalObject*>(exec_state->lexicalGlobalObject());
  JSCExceptionState exception_state(global_object);
  JSC::JSObject* this_object =
      exec_state->hostThisValue().toThisObject(exec_state);
  NumericTypesTestInterface* impl =
      GetWrappableOrSetException<NumericTypesTestInterface>(exec_state, this_object);
  if (!impl) {
    return JSC::JSValue::encode(exec_state->exception());
  }

  TypeTraits<double >::ReturnType return_value = impl->UnrestrictedDoubleReturnOperation();
  return JSC::JSValue::encode(ToJSValue(global_object, return_value));

}

JSC::EncodedJSValue functionJSunsignedLongArgumentOperation(
    JSC::ExecState* exec_state) {
  TRACE_EVENT0("JSCNumericTypesTestInterface", "call unsignedLongArgumentOperation");
  JSCGlobalObject* global_object =
      JSC::jsCast<JSCGlobalObject*>(exec_state->lexicalGlobalObject());
  JSCExceptionState exception_state(global_object);
  JSC::JSObject* this_object =
      exec_state->hostThisValue().toThisObject(exec_state);
  NumericTypesTestInterface* impl =
      GetWrappableOrSetException<NumericTypesTestInterface>(exec_state, this_object);
  if (!impl) {
    return JSC::JSValue::encode(exec_state->exception());
  }

  const size_t kMinArguments = 1;
  if (exec_state->argumentCount() < kMinArguments) {
    return JSC::throwVMNotEnoughArgumentsError(exec_state);
  }
  // Non-optional arguments
  TypeTraits<uint32_t >::ConversionType arg1;

  DCHECK_LT(0, exec_state->argumentCount());
  FromJSValue(exec_state,
      exec_state->argument(0),
      kNoConversionFlags,
      &exception_state, &arg1);
  if (exception_state.is_exception_set()) {
    return JSC::throwVMError(exec_state, exception_state.exception_object());
  }
  impl->UnsignedLongArgumentOperation(arg1);
  return JSC::JSValue::encode(JSC::jsUndefined());

}

JSC::EncodedJSValue functionJSunsignedLongLongArgumentOperation(
    JSC::ExecState* exec_state) {
  TRACE_EVENT0("JSCNumericTypesTestInterface", "call unsignedLongLongArgumentOperation");
  JSCGlobalObject* global_object =
      JSC::jsCast<JSCGlobalObject*>(exec_state->lexicalGlobalObject());
  JSCExceptionState exception_state(global_object);
  JSC::JSObject* this_object =
      exec_state->hostThisValue().toThisObject(exec_state);
  NumericTypesTestInterface* impl =
      GetWrappableOrSetException<NumericTypesTestInterface>(exec_state, this_object);
  if (!impl) {
    return JSC::JSValue::encode(exec_state->exception());
  }

  const size_t kMinArguments = 1;
  if (exec_state->argumentCount() < kMinArguments) {
    return JSC::throwVMNotEnoughArgumentsError(exec_state);
  }
  // Non-optional arguments
  TypeTraits<uint64_t >::ConversionType arg1;

  DCHECK_LT(0, exec_state->argumentCount());
  FromJSValue(exec_state,
      exec_state->argument(0),
      kNoConversionFlags,
      &exception_state, &arg1);
  if (exception_state.is_exception_set()) {
    return JSC::throwVMError(exec_state, exception_state.exception_object());
  }
  impl->UnsignedLongLongArgumentOperation(arg1);
  return JSC::JSValue::encode(JSC::jsUndefined());

}

JSC::EncodedJSValue functionJSunsignedLongLongReturnOperation(
    JSC::ExecState* exec_state) {
  TRACE_EVENT0("JSCNumericTypesTestInterface", "call unsignedLongLongReturnOperation");
  JSCGlobalObject* global_object =
      JSC::jsCast<JSCGlobalObject*>(exec_state->lexicalGlobalObject());
  JSCExceptionState exception_state(global_object);
  JSC::JSObject* this_object =
      exec_state->hostThisValue().toThisObject(exec_state);
  NumericTypesTestInterface* impl =
      GetWrappableOrSetException<NumericTypesTestInterface>(exec_state, this_object);
  if (!impl) {
    return JSC::JSValue::encode(exec_state->exception());
  }

  TypeTraits<uint64_t >::ReturnType return_value = impl->UnsignedLongLongReturnOperation();
  return JSC::JSValue::encode(ToJSValue(global_object, return_value));

}

JSC::EncodedJSValue functionJSunsignedLongReturnOperation(
    JSC::ExecState* exec_state) {
  TRACE_EVENT0("JSCNumericTypesTestInterface", "call unsignedLongReturnOperation");
  JSCGlobalObject* global_object =
      JSC::jsCast<JSCGlobalObject*>(exec_state->lexicalGlobalObject());
  JSCExceptionState exception_state(global_object);
  JSC::JSObject* this_object =
      exec_state->hostThisValue().toThisObject(exec_state);
  NumericTypesTestInterface* impl =
      GetWrappableOrSetException<NumericTypesTestInterface>(exec_state, this_object);
  if (!impl) {
    return JSC::JSValue::encode(exec_state->exception());
  }

  TypeTraits<uint32_t >::ReturnType return_value = impl->UnsignedLongReturnOperation();
  return JSC::JSValue::encode(ToJSValue(global_object, return_value));

}

JSC::EncodedJSValue functionJSunsignedShortArgumentOperation(
    JSC::ExecState* exec_state) {
  TRACE_EVENT0("JSCNumericTypesTestInterface", "call unsignedShortArgumentOperation");
  JSCGlobalObject* global_object =
      JSC::jsCast<JSCGlobalObject*>(exec_state->lexicalGlobalObject());
  JSCExceptionState exception_state(global_object);
  JSC::JSObject* this_object =
      exec_state->hostThisValue().toThisObject(exec_state);
  NumericTypesTestInterface* impl =
      GetWrappableOrSetException<NumericTypesTestInterface>(exec_state, this_object);
  if (!impl) {
    return JSC::JSValue::encode(exec_state->exception());
  }

  const size_t kMinArguments = 1;
  if (exec_state->argumentCount() < kMinArguments) {
    return JSC::throwVMNotEnoughArgumentsError(exec_state);
  }
  // Non-optional arguments
  TypeTraits<uint16_t >::ConversionType arg1;

  DCHECK_LT(0, exec_state->argumentCount());
  FromJSValue(exec_state,
      exec_state->argument(0),
      kNoConversionFlags,
      &exception_state, &arg1);
  if (exception_state.is_exception_set()) {
    return JSC::throwVMError(exec_state, exception_state.exception_object());
  }
  impl->UnsignedShortArgumentOperation(arg1);
  return JSC::JSValue::encode(JSC::jsUndefined());

}

JSC::EncodedJSValue functionJSunsignedShortReturnOperation(
    JSC::ExecState* exec_state) {
  TRACE_EVENT0("JSCNumericTypesTestInterface", "call unsignedShortReturnOperation");
  JSCGlobalObject* global_object =
      JSC::jsCast<JSCGlobalObject*>(exec_state->lexicalGlobalObject());
  JSCExceptionState exception_state(global_object);
  JSC::JSObject* this_object =
      exec_state->hostThisValue().toThisObject(exec_state);
  NumericTypesTestInterface* impl =
      GetWrappableOrSetException<NumericTypesTestInterface>(exec_state, this_object);
  if (!impl) {
    return JSC::JSValue::encode(exec_state->exception());
  }

  TypeTraits<uint16_t >::ReturnType return_value = impl->UnsignedShortReturnOperation();
  return JSC::JSValue::encode(ToJSValue(global_object, return_value));

}
JSC::JSValue NamedPropertyGetter(JSC::ExecState* exec_state,
    JSC::JSValue slot_base, JSC::PropertyName property_name) {
  NOTREACHED();
  return JSC::jsUndefined();
}
bool QueryNamedProperty(JSC::JSCell* cell, JSC::ExecState* exec_state,
    JSC::PropertyName property_name) {
  NOTREACHED();
  return false;
}
void NamedPropertySetter(JSC::JSCell* cell, JSC::ExecState* exec_state,
    JSC::PropertyName property_name, JSC::JSValue jsc_value) {
  NOTREACHED();
}

bool NamedPropertyDeleter(JSC::JSCell* cell, JSC::ExecState* exec_state,
    JSC::PropertyName property_name) {
  return false;
}

#if !defined(COBALT_BUILD_TYPE_GOLD)
JSC::JSValue OnGetMissingProperty(JSC::ExecState* exec_state,
    JSC::JSValue slot_base, JSC::PropertyName property_name) {
  JSCGlobalObject* global_object =
      JSC::jsCast<JSCGlobalObject*>(exec_state->lexicalGlobalObject());
  JSC::JSValue callable = global_object->get(
      exec_state, JSC::Identifier(exec_state, "__onGetMissingProperty"));
  if (!callable.isUndefined()) {
    JSC::CallData call_data;
    JSC::CallType call_type = JSC::getCallData(callable, call_data);
    if (call_type != JSC::CallTypeNone) {
      // The function called __onGetMissingProperty exists, so call this and
      // return the result as the value for this property.
      JSC::MarkedArgumentBuffer args;
      args.append(slot_base);
      args.append(JSC::JSValue(
              JSC::JSString::create(
                  global_object->globalData(), property_name.publicName())));
      JSC::JSValue retval = JSC::call(
          exec_state, callable, call_type, call_data, global_object, args);
      return retval;
    }
  }
  return JSC::jsUndefined();
}

bool OnSetMissingProperty(JSC::JSCell* cell, JSC::ExecState* exec_state,
    JSC::PropertyName property_name, JSC::JSValue value) {
  JSCGlobalObject* global_object =
      JSC::jsCast<JSCGlobalObject*>(exec_state->lexicalGlobalObject());
  JSC::JSValue callable = global_object->get(
      exec_state, JSC::Identifier(exec_state, "__onSetMissingProperty"));
  if (!callable.isUndefined()) {
    JSC::CallData call_data;
    JSC::CallType call_type = JSC::getCallData(callable, call_data);
    if (call_type != JSC::CallTypeNone) {
      // The function called __onSetMissingProperty exists, so call this with
      // the value to be set. The missing property handler returns true if it
      // has handled the setting of this property.
      JSC::MarkedArgumentBuffer args;
      args.append(cell);
      args.append(JSC::JSValue(
              JSC::JSString::create(
                  global_object->globalData(), property_name.publicName())));
      args.append(value);
      JSC::JSValue retval = JSC::call(
          exec_state, callable, call_type, call_data, global_object, args);
      return retval.toBoolean(exec_state);
    }
  }
  return false;
}
#else
JSC::JSValue OnGetMissingProperty(JSC::ExecState* exec_state,
    JSC::JSValue slot_base, JSC::PropertyName property_name) {
  NOTREACHED();
  return JSC::jsUndefined();
}
bool OnSetMissingProperty(JSC::JSCell* cell, JSC::ExecState* exec_state,
    JSC::PropertyName property_name, JSC::JSValue value) {
  NOTREACHED();
  return false;
}
#endif
}  // namespace

}  // namespace testing
}  // namespace bindings
}  // namespace cobalt
