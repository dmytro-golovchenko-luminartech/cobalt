Evergreen Test Automation
=============

The Evergreen test automation reduces the overhead of running the test cases
required to test Evergreen-specific functionality. These tests must be run both
internally and by partners, and making them simple and fast is good for all.

Structure
=============

The Evergreen test automation framework is made up of a few distinct sets of
files.

**Core Scripts**

These are files that are responsible for finding all of the tests, executing all
of the tests, and outputting the results.

* `run_all_tests.sh`
* `setup.sh`
* `pprint.sh`

**Shared Scripts**

These files contain code that is either non-trivial or repeated throughout the
tests, and is shared across all platforms.

* `shared/app_key.sh`
* `shared/drain_file.sh`
* `shared/init_logging.sh`
* `shared/installation_slot.sh`
* `shared/wait_and_watch.sh`

**Platform-Specific Scripts**

These files contain code that is either non-trivial or repeated throughout the
tests, and is platform specific.

* `<PLATFORM>/clean_up.sh`
* `<PLATFORM>/clear_storage.sh`
* `<PLATFORM>/create_file.sh`
* `<PLATFORM>/delete_file.sh`
* `<PLATFORM>/deploy_cobalt.sh`
* `<PLATFORM>/run_command.sh`
* `<PLATFORM>/setup.sh`
* `<PLATFORM>/start_cobalt.sh`
* `<PLATFORM>/stop_cobalt.sh`

**Test HTML**

These files are responsible for changing the channels when tests are running.

* `tests/empty.html`
* `tests/test.html`
* `tests/tseries.html`

**Test Cases**

These files are responsible for the test logic, and each file corresponds to a
single Evergreen test case.

* `tests/abort_update_if_already_updating_test.sh`
* `tests/alternative_content_test.sh`
* `tests/continuous_updates_test.sh`
* `tests/crashing_binary_test.sh`
* `tests/disabled_updater_test.sh`
* `tests/load_slot_being_updated_test.sh`
* `tests/mismatched_architecture_test.sh`
* `tests/noop_binary_test.sh`
* `tests/out_of_storage_test.sh`
* `tests/quick_roll_forward_test.sh`
* `tests/racing_updaters_test.sh`
* `tests/update_fails_verification_test.sh`
* `tests/update_works_for_only_one_app_test.sh`
* `tests/valid_slot_overwritten_test.sh`
* `tests/verify_qa_channel_update_test.sh`

How To Run
=============

Before the tests can be run, the targeted platform will need each of the
required scripts to be created and implemented. See the linux subdirectory for
additional information.

The exact requirements to run the Evergreen tests will vary between platforms.
The example below assumes that the target platform to run on is Linux.

First, a directory tree containing the required binaries and content needs to be
created. This directory tree must be in the following format:

```
  root
   +-- deploy
        +-- loader_app
             +-- loader_app <-- loader_app binary
             +-- content    <-- loader_app content
                  +-- app
                       +-- cobalt
                            +-- content           <-- cobalt content
                            +-- lib
                                 +-- libcobalt.so <-- cobalt binary
```

Note: This directory structure is the same as what would be generated by
      `starboard/evergreen/shared/launcher.py`.

Next, set the environment variable `OUT` equal to the root of the directory tree
created above.

Finally, run the `run_all_tests.sh` script with one argument, `linux`. The tests
can run anywhere from 15 to 30 minutes, so it is recommended to background the
task and redirect all output to a separate file, e.g.:

```
  ./run_all_test.sh linux &> results &
```

Notes
=============

Evergreen uses "drain" files to ensure only one application downloads an update
at a time. To fake update contention, some tests create this file manually:

* `tests/abort_update_if_already_updating_test.sh`
* `tests/load_slot_being_updated_test.sh`
* `tests/racing_updaters_test.sh`

Evergreen uses "app key" files to keep track of per-application state of an
update. To fake changes to the per-application state of an update, some tests
create, delete, or modify these files manually:

* `tests/update_works_for_only_one_app_test.sh`
* `tests/valid_slot_overwritten_test.sh`

To validate Evergreen behavior when there is not enough storage for an update, a
temporary filesystem is used, only 10MiB in size. One test creates a symbolic
link from the storage path to this filesystem, faking an "out of storage"
situation:

* `tests/out_of_storage_test.sh`
